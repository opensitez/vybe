// vybe Grammar for pest parser
// Case-insensitive parsing

WHITESPACE = _{ " " | "\t" | line_continuation }
COMMENT = _{ ("'" | ^"REM") ~ (!NEWLINE ~ ANY)* }
NEWLINE = { "\r\n" | "\n" | "\r" }

// Line continuation: underscore at end of line joins the next line
// Must NOT match identifiers containing "_" â€” only matches "_" followed by optional whitespace and newline
line_continuation = _{ "_" ~ (" " | "\t")* ~ ("\r\n" | "\n" | "\r") }

// Program structure
program = { SOI ~ line* ~ EOI }
line = _{ imports_statement | attribute_line | statement_line | NEWLINE | COMMENT }
statement_line = {
    (
        (sub_decl | function_decl)
        | (statement ~ (":" ~ statement)*)
    ) ~ (NEWLINE | EOI)
}

// Attributes: <...> _ (skipped, consumed but ignored)
attribute = _{ "<" ~ (!(">" ~ WHITESPACE* ~ ("_" ~ WHITESPACE* ~ (NEWLINE | EOI))?) ~ ANY)* ~ ">" ~ (WHITESPACE* ~ "_" ~ WHITESPACE* ~ (NEWLINE | EOI))? }
attribute_line = _{ attribute ~ (NEWLINE | EOI)? }

// Imports statement (skipped)
imports_statement = _{ ^"Imports" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }

// Statements
statement = _{
    module_decl
    | class_decl
    | enum_decl
    | sub_decl
    | function_decl
    | const_statement
    | dim_statement
    | redim_statement
    | set_statement
    | dot_assign_statement
    | me_assign_statement
    | assign_statement
    | single_line_if_statement
    | if_statement
    | for_each_statement
    | for_statement
    | while_statement
    | do_loop_statement
    | select_statement
    | with_statement
    | try_statement
    | continue_statement
    | exit_statement
    | return_statement
    | line_input_statement
    | open_statement
    | close_statement
    | print_file_statement
    | write_file_statement
    | input_file_statement
    | call_statement
    | expression_statement
}

// Declarations
dim_new_keyword = { ^"New" }
dim_statement = {
    ^"Dim" ~ identifier ~
    ("(" ~ array_bounds? ~ ")")? ~
    (^"As" ~ dim_new_keyword? ~ type_name ~ ("(" ~ argument_list? ~ ")")?)? ~
    ("=" ~ (array_literal | expression))?
}

const_statement = { (^"Public" | ^"Private")? ~ ^"Const" ~ identifier ~ ^"As" ~ type_name ~ "=" ~ expression }
set_statement = { ^"Set" ~ identifier ~ "=" ~ expression }
assign_statement = { identifier ~ ("." ~ identifier)* ~ ("(" ~ expression ~ ("," ~ expression)* ~ ")")? ~ "=" ~ expression }
redim_statement = { ^"ReDim" ~ (^"Preserve")? ~ identifier ~ "(" ~ array_bounds ~ ")" }

// Array support
array_bounds = { expression ~ ("," ~ expression)* }
array_literal = { "{" ~ expression ~ ("," ~ expression)* ~ "}" }

// Control flow
single_line_if_statement = {
    ^"If" ~ expression ~ ^"Then" ~ single_line_then_body ~ (^"Else" ~ single_line_then_body)?
}
single_line_then_body = { single_line_stmt ~ (":" ~ single_line_stmt)* }
single_line_stmt = _{
    return_statement
    | exit_statement
    | set_statement
    | dot_assign_statement
    | me_assign_statement
    | assign_statement
    | call_statement
    | expression_statement
}

if_statement = {
    ^"If" ~ expression ~ ^"Then" ~ (NEWLINE | EOI)
    ~ if_body
    ~ elseif_block*
    ~ else_block?
    ~ if_end
}
if_body = { (!if_control ~ line)* }
if_control = { ^"ElseIf" | ^"Else" | if_end }
elseif_block = { ^"ElseIf" ~ expression ~ ^"Then" ~ (NEWLINE | EOI) ~ if_body }
else_block = { ^"Else" ~ (NEWLINE | EOI) ~ if_body }
if_end = { ^"End" ~ ^"If" }

for_statement = {
    ^"For" ~ identifier ~ "=" ~ expression ~ ^"To" ~ expression ~ (^"Step" ~ expression)? ~ (NEWLINE | EOI)
    ~ (!for_end ~ line)*
    ~ for_end
}
for_end = { ^"Next" ~ identifier? }

for_each_statement = {
    ^"For" ~ ^"Each" ~ identifier ~ (^"As" ~ type_name)? ~ ^"In" ~ expression ~ (NEWLINE | EOI)
    ~ (!for_end ~ line)*
    ~ for_end
}

while_statement = {
    ^"While" ~ expression ~ (NEWLINE | EOI)
    ~ (!while_end ~ line)*
    ~ while_end
}
while_end = { ^"Wend" | ^"End" ~ ^"While" }

do_loop_statement = {
    ^"Do" ~ (^"While" ~ expression | ^"Until" ~ expression)? ~ (NEWLINE | EOI)
    ~ (!do_end ~ line)*
    ~ do_end
}
do_end = { ^"Loop" ~ (^"While" ~ expression | ^"Until" ~ expression)? }

select_statement = {
    ^"Select" ~ ^"Case" ~ expression ~ (NEWLINE | EOI)
    ~ case_block*
    ~ case_else?
    ~ select_end
}

case_block = {
    ^"Case" ~ case_conditions ~ (NEWLINE | EOI)
    ~ (!case_control ~ line)*
}

case_conditions = { case_condition ~ ("," ~ case_condition)* }

case_condition = {
    ^"Is" ~ comp_op ~ expression           // Case Is > 10
    | expression ~ ^"To" ~ expression      // Case 1 To 10
    | expression                           // Case 5
}

case_else = {
    ^"Case" ~ ^"Else" ~ (NEWLINE | EOI)
    ~ (!select_end ~ line)*
}

case_control = _{ ^"Case" | select_end }
select_end = { ^"End" ~ ^"Select" }

// With...End With
with_statement = {
    ^"With" ~ expression ~ (NEWLINE | EOI)
    ~ (!with_end ~ line)*
    ~ with_end
}
with_end = { ^"End" ~ ^"With" }

// Dot-member access for With blocks: .Property = value, .Method(args)
dot_assign_statement = { "." ~ identifier ~ ("." ~ identifier)* ~ "=" ~ expression }
dot_call_statement = { "." ~ identifier ~ ("." ~ identifier)* ~ "(" ~ argument_list? ~ ")" }
dot_member_access = { "." ~ identifier ~ ("." ~ identifier)* }

// Try-Catch-Finally
try_statement = {
    ^"Try" ~ (NEWLINE | EOI)
    ~ try_body
    ~ catch_block*
    ~ finally_block?
    ~ try_end
}
try_body = { (!try_control ~ line)* }
catch_block = { ^"Catch" ~ (identifier ~ ^"As" ~ type_name)? ~ (^"When" ~ expression)? ~ (NEWLINE | EOI) ~ try_body }
finally_block = { ^"Finally" ~ (NEWLINE | EOI) ~ try_body }
try_end = { ^"End" ~ ^"Try" }
try_control = _{ ^"Catch" | ^"Finally" | try_end }

continue_statement = { ^"Continue" ~ (^"Do" | ^"For" | ^"While") }

// VB6 File I/O statements
open_statement = { ^"Open" ~ expression ~ ^"For" ~ file_mode ~ ^"As" ~ "#"? ~ expression }
file_mode = { ^"Input" | ^"Output" | ^"Append" | ^"Binary" | ^"Random" }
close_statement = { ^"Close" ~ ("#"? ~ expression ~ ("," ~ "#"? ~ expression)*)? }
print_file_statement = { ^"Print" ~ "#" ~ expression ~ "," ~ argument_list? }
write_file_statement = { ^"Write" ~ "#" ~ expression ~ "," ~ argument_list? }
input_file_statement = { ^"Input" ~ "#" ~ expression ~ "," ~ identifier ~ ("," ~ identifier)* }
line_input_statement = { ^"Line" ~ ^"Input" ~ "#" ~ expression ~ "," ~ identifier }

exit_statement = { ^"Exit" ~ exit_kind }
exit_kind = { ^"Sub" | ^"Function" | ^"For" | ^"Do" | ^"Select" | ^"Try" | ^"While" }
return_statement = { ^"Return" ~ expression? }

// Procedure declarations
// sub_modifier covers: Public, Private, Protected, Friend, Overrides, Overloads, Shared, etc.
sub_modifier = _{ ^"Public" | ^"Private" | ^"Protected" | ^"Friend" | ^"Overrides" | ^"Overloads" | ^"Shared" | ^"MustOverride" | ^"Overridable" | ^"NotOverridable" }
sub_name = { identifier | ^"New" }
handles_clause = { ^"Handles" ~ dotted_identifier ~ ("," ~ dotted_identifier)* }
sub_decl = {
    attribute_line* ~
    sub_modifier* ~ ^"Sub" ~ sub_name ~ "(" ~ param_list? ~ ")" ~ handles_clause?
    ~ (sub_inline_body | sub_block_body)
}
sub_inline_body = { ":" ~ statement? ~ (":" ~ statement)* ~ ":" ~ sub_end }
sub_block_body = { (NEWLINE | EOI) ~ (!sub_end ~ line)* ~ sub_end }
sub_end = { ^"End" ~ ^"Sub" }

function_decl = {
    attribute_line* ~
    sub_modifier* ~ ^"Function" ~ identifier ~ "(" ~ param_list? ~ ")" ~ (^"As" ~ type_name)?
    ~ (func_inline_body | func_block_body)
}
func_inline_body = { ":" ~ statement? ~ (":" ~ statement)* ~ ":" ~ func_end }
func_block_body = { (NEWLINE | EOI) ~ (!func_end ~ line)* ~ func_end }
func_end = { ^"End" ~ ^"Function" }

param_list = { param ~ ("," ~ param)* }
param = { (^"ByVal" | ^"ByRef")? ~ (^"Optional")? ~ identifier ~ (^"As" ~ type_name)? ~ ("=" ~ expression)? }

// Module declarations (VB.NET style - members are implicitly shared)
module_decl = {
    (^"Public" | ^"Private" | ^"Friend")? ~ ^"Module" ~ identifier ~ (NEWLINE | EOI)
    ~ (!module_end ~ (sub_decl | function_decl | const_statement_line | field_line | dim_line | class_decl | enum_decl | NEWLINE | COMMENT))*
    ~ module_end
}
module_end = { ^"End" ~ ^"Module" }
const_statement_line = _{ const_statement ~ (NEWLINE | EOI) }

// Class declarations
partial_keyword = { ^"Partial" }
inherits_statement = { ^"Inherits" ~ type_name }
inherits_line = _{ inherits_statement ~ (NEWLINE | EOI) }
visibility_modifier = { ^"Public" | ^"Private" | ^"Protected" | ^"Friend" }

class_decl = {
    attribute_line* ~
    class_modifier* ~ ^"Class" ~ identifier ~ (NEWLINE | EOI)
    ~ inherits_line?
    ~ (!class_end ~ (property_decl | sub_decl | function_decl | field_line | dim_line | imports_statement | attribute_line | NEWLINE | COMMENT))*
    ~ class_end
}
class_modifier = _{ partial_keyword | visibility_modifier }

class_end = { ^"End" ~ ^"Class" }
dim_line = _{ dim_statement ~ (NEWLINE | EOI) }

// Enum declarations
enum_decl = {
    (^"Public" | ^"Private" | ^"Friend")? ~ ^"Enum" ~ identifier ~ (NEWLINE | EOI)
    ~ (!enum_end ~ (enum_member | NEWLINE | COMMENT))*
    ~ enum_end
}
enum_member = { identifier ~ ("=" ~ expression)? ~ (NEWLINE | EOI) }
enum_end = { ^"End" ~ ^"Enum" }

// Field declarations: now support Friend, WithEvents, and dotted type names
withevents_keyword = { ^"WithEvents" }
field_decl = { (^"Public" | ^"Private" | ^"Protected" | ^"Friend") ~ withevents_keyword? ~ identifier ~ ("(" ~ array_bounds? ~ ")")? ~ (^"As" ~ dim_new_keyword? ~ type_name)? ~ ("=" ~ (array_literal | expression))? }
field_line = _{ field_decl ~ (NEWLINE | EOI) }

property_decl = {
    (^"Public" | ^"Private")? ~ ^"Property" ~ identifier ~ "(" ~ param_list? ~ ")" ~ (^"As" ~ type_name)? ~ (NEWLINE | EOI)
    ~ (property_get | property_set | NEWLINE)*
    ~ property_end
}

property_get = {
    ^"Get" ~ (NEWLINE | EOI)
    ~ (!get_end ~ line)*
    ~ get_end
}

property_set = {
    ^"Set" ~ "(" ~ param ~ ")" ~ (NEWLINE | EOI)
    ~ (!set_end ~ line)*
    ~ set_end
}

property_end = { ^"End" ~ ^"Property" }
get_end = { ^"End" ~ ^"Get" }
set_end = { ^"End" ~ ^"Set" }

// Expressions
expression = { logical_or }

logical_or = { logical_and ~ (or_op ~ logical_and)* }
logical_and = { equality ~ (and_op ~ equality)* }
equality = { comparison ~ (eq_op ~ comparison)* }
comparison = { additive ~ (comp_op ~ additive)* }
additive = { multiplicative ~ (add_op ~ multiplicative)* }
multiplicative = { unary ~ (mult_op ~ unary)* }
unary = { (not_op | neg_op)? ~ primary }

or_op = { ^"Or" | ^"OrElse" }
and_op = { ^"And" | ^"AndAlso" }
eq_op = { ^"=" | ^"<>" | ^"Is" | ^"IsNot" }
comp_op = { ^"<=" | ^">=" | "<" | ">" }
add_op = { "+" | "-" | "&" }
mult_op = { "*" | "/" | "\\" | ^"Mod" }
not_op = { ^"Not" }
neg_op = { "-" }

// Me keyword rules
me_keyword = { ^"Me" }
me_member_call = { me_keyword ~ ("." ~ identifier)+ ~ "(" ~ argument_list? ~ ")" }
me_member_access = { me_keyword ~ ("." ~ identifier)+ }
me_assign_statement = { me_keyword ~ ("." ~ identifier)+ ~ "=" ~ expression }

// Dotted identifier: System.Windows.Forms.Button
dotted_identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* ~ ("." ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*)* }

primary = _{
    new_expression
    | literal
    | me_member_call
    | me_member_access
    | me_keyword
    | member_call
    | call_expression
    | member_access
    | identifier
    | "(" ~ expression ~ ")"
}

// New expression: supports dotted identifiers like New System.Windows.Forms.Button()
new_expression = { ^"New" ~ dotted_identifier ~ ("(" ~ argument_list? ~ ")")? }

call_expression = { identifier ~ "(" ~ argument_list? ~ ")" }
member_call = { identifier ~ ("." ~ identifier)+ ~ ("(" ~ argument_list? ~ ")")? }
call_statement = {
    ^"Call"? ~ (
        me_member_call
        | member_call
        | member_access
        | call_expression
        | identifier ~ argument_list
        | identifier
    )
}
expression_statement = { dot_call_statement | me_member_call | member_call | call_expression | member_access | dot_member_access }

member_access = { identifier ~ ("." ~ identifier)+ }
argument_list = { expression ~ ("," ~ expression)* }

// Literals
literal = _{
    array_literal
    | string_literal
    | numeric_literal
    | boolean_literal
    | ^"Nothing"
}

string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
// Numeric literals: support optional type suffix (F, D, L, S, US, UI, UL, R, !)
numeric_literal = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? ~ (^"F" | ^"D" | ^"L" | ^"R" | ^"S" | ^"US" | ^"UI" | ^"UL" | "!" | "#" | "@" | "%")? }
boolean_literal = { ^"True" | ^"False" }

// Types: support dotted type names like System.Windows.Forms.Form
type_name = {
    ^"Integer"
    | ^"Long"
    | ^"Single"
    | ^"Double"
    | ^"String"
    | ^"Boolean"
    | ^"Variant"
    | ^"Object"
    | dotted_identifier
}

// Identifiers
identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Keywords
keyword = _{
    (^"Me" | ^"If" | ^"Then" | ^"Else" | ^"End" | ^"Sub" | ^"Function" | ^"Dim" | ^"ReDim" | ^"Preserve" | ^"Const" | ^"As" | ^"Set" | ^"For" | ^"To" | ^"Step" | ^"Next" | ^"While" | ^"Wend" | ^"Do" | ^"Loop" | ^"Until" | ^"Exit" | ^"Return" | ^"Call" | ^"True" | ^"False" | ^"Nothing" | ^"Not" | ^"Or" | ^"And" | ^"Mod" | ^"Module" | ^"Class" | ^"Private" | ^"Public" | ^"ByVal" | ^"ByRef" | ^"Select" | ^"Case" | ^"Try" | ^"Catch" | ^"Finally" | ^"Continue" | ^"New" | ^"When" | ^"Partial" | ^"Friend" | ^"Protected" | ^"Overrides" | ^"Overloads" | ^"Shared" | ^"WithEvents" | ^"Handles" | ^"Imports" | ^"Is" | ^"IsNot" | ^"AndAlso" | ^"OrElse" | ^"Optional" | ^"MyBase" | ^"MustOverride" | ^"Overridable" | ^"NotOverridable" | ^"With" | ^"Each" | ^"In" | ^"Enum" | ^"Open" | ^"Close" | ^"Print" | ^"Line" | ^"Input" | ^"Write" | ^"Append" | ^"Output" | ^"Binary" | ^"Random")
    ~ !(ASCII_ALPHANUMERIC | "_")
}
